from .base import Module, Conv2d, askeras

from torch import zeros, tensor, arange, where, float32


class Demosaic(Module):

    def __init__(self, dfilter, bayer_pattern, *scales):
        super().__init__()
        assert bayer_pattern.lower() in ("rggb", "bggr", "grbg", "gbrg")
        bayer_pattern = tensor(['rgb'.index(c) for c in bayer_pattern.lower()])
        rows = tensor([0, 0, 1, 1])
        cols = tensor([0, 1, 0, 1])
        # assign kernels from specific filter method
        getattr(self, dfilter+'_init')()
        # The basic idea is to apply kxk kernels to two consecutive
        # rows/columns similtaneously, so we will need a (k+1)x(k+1)
        # kernel to give it the proper receptive field.  For a given
        # row or column in the 2x2 bayer grid, we need to either slice
        # the kxk kernel into the first or last k rows/columns of the
        # (k+1)x(k+1) generated kernel.
        kslice = slice(None, -1), slice(1, None)
        weight = zeros(4, 3, self.k+1, self.k+1, requires_grad=False)

        # Set values for which the bayer image IS ground truth.
        # +self.k//2 because 2x2 bayer is centered in the (k+1)x(k+1)
        # kernel.
        weight[arange(4), bayer_pattern, rows+self.k//2, cols+self.k//2] = 1

        # Finishing off red bayer locations
        r = bayer_pattern == 'rgb'.index('r')
        slicey, slicex = kslice[rows[r]], kslice[cols[r]]
        weight[r, 'rgb'.index('g'), slicey, slicex] = self.GatR
        weight[r, 'rgb'.index('b'), slicey, slicex] = self.BatR

        # Finishing off blue bayer locations
        b = bayer_pattern == 'rgb'.index('b')
        slicey, slicex = kslice[rows[b]], kslice[cols[b]]
        weight[b, 'rgb'.index('g'), slicey, slicex] = self.GatB
        weight[b, 'rgb'.index('r'), slicey, slicex] = self.RatB

        # greens get a bit more interesting because there are two
        # types: one in red rows, and one in blue rows.
        g, = where(bayer_pattern == 'rgb'.index('g'))
        # read "gbr" as green pixel in blue row, red column
        if any(b[:2]):  # if b is in the first row.  
            gbr, grb = g
        else:
            grb, gbr = g
        slicey, slicex = kslice[rows[grb]], kslice[cols[grb]]
        weight[grb, 'rgb'.index('r'), slicey, slicex] = self.RatGRB
        weight[grb, 'rgb'.index('b'), slicey, slicex] = self.BatGRB
        slicey, slicex = kslice[rows[gbr]], kslice[cols[gbr]]
        weight[gbr, 'rgb'.index('r'), slicey, slicex] = self.RatGBR
        weight[gbr, 'rgb'.index('b'), slicey, slicex] = self.BatGBR

        # apply YUV to RGB transform if necessary.  This is equivalent
        # to scaling values AFTER applying filter.
        for i, scale in enumerate(scales):
            weight[:, i] *= float(scale)

        # create the convulotion.
        self.module = Conv2d(1, 12, (self.k+1, self.k+1), 2)
        self.module.weight.data[:] = weight.reshape(12, 1, self.k+1, self.k+1)

    def simple_init(self):
        # generated by reading a 'demosaic.cpp' sent to me
        self.GatR = tensor([[0, 1, 0],
                            [1, 0, 1],
                            [0, 1, 0]]
                           ) / 4
        # read "GRB" as green bayer location in red row, blue column.
        self.RatGRB = tensor([[0, 0, 0],
                              [1, 0, 1],
                              [0, 0, 0]]
                             ) / 2
        self.RatB = tensor([[1, 0, 1],
                            [0, 0, 0],
                            [1, 0, 1]],
                           ) / 4
        self.k = 3
        self.basic_init()

    def malvar_init(self):
        # kernels taken from https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/Demosaicing_ICASSP04.pdf
        self.GatR = tensor([[ 0  , 0  ,-1  , 0  , 0  ],
                            [ 0  , 0  , 2  , 0  , 0  ],
                            [-1  , 2  , 4  , 2  ,-1  ],
                            [ 0  , 0  , 2  , 0  , 0  ],
                            [ 0  , 0  ,-1  , 0  , 0  ]],
                           dtype=float32)
        # read "GRB" as green bayer location in red row, blue column.
        self.RatGRB = tensor([[ 0  , 0  , 0.5, 0  , 0  ],
                              [ 0  ,-1  , 0  ,-1  , 0  ],
                              [-1  , 4  , 5  , 4  ,-1  ],
                              [ 0  ,-1  , 0  ,-1  , 0  ],
                              [ 0  , 0  , 0.5, 0  , 0  ]],
                             dtype=float32)
        self.RatB = tensor([[ 0  , 0  ,-1.5, 0  , 0  ],
                            [ 0  , 2  , 0  , 2  , 0  ],
                            [-1.5, 0  , 6  , 0  ,-1.5],
                            [ 0  , 2  , 0  , 2  , 0  ],
                            [ 0  , 0  ,-1.5, 0  , 0  ]],
                           dtype=float32)
        self.k = 5
        self.basic_init()

    def basic_init(self):
        self.GatB = self.GatR
        # read "GRB" as green bayer location in red row, blue column.
        self.BatGBR = self.RatGRB
        self.RatGBR = self.RatGRB.T
        self.BatGRB = self.RatGBR
        self.BatR = self.RatB


def reshape_conv(old_conv):
    assert (all(k in (3, 4) for k in old_conv.kernel_size)
            and old_conv.stride == 2
            and old_conv.in_channels == 3
            and not old_conv.use_bias)
    # first 2x2 is demosaic output, second 2x2 is this new conv's
    # input.
    weight = zeros(old_conv.out_channels, 2, 2, 3, 2, 2)
    old_weight = old_conv.weight.data
    # This is the best image I can use to try and describe (for 3x3
    # starting kernel):
    #
    #     0   1   2
    #   l       l       l
    #   +---+---+---+ - + -
    # 0 |rgb rgblrgb|rgb
    #   +   +   +   +   +  0
    # 1 |rgb rgblrgb|rgb
    #   + - + - + - + - + -
    # 2 |rgb rgblrgb|rgb
    #   +---+---+---+   +  1
    #   lrgb rgblrgb rgb
    #   + - + - + - + - + -
    #   l       l       l
    #       0       1
    #
    # The left/top coordinates and ('|', '---') are in terms of the
    # original kernel, and the right/bottom coordinates and ('l', ' -
    # ') are in terms of the new input coordinates.  I use the
    # coordinates above in the later comments.  The 3x3 box is the
    # orignal conv kernel.  Each of the 4 2x2 blocks above have been
    # transformed into one pixel of the demosaic output.

    # (0, 0) in right/bottom coordinates
    weight[:, 0, 0, :, 0, 0] = old_weight[:, :, 0, 0]
    weight[:, 0, 1, :, 0, 0] = old_weight[:, :, 0, 1]
    weight[:, 1, 0, :, 0, 0] = old_weight[:, :, 1, 0]
    weight[:, 1, 1, :, 0, 0] = old_weight[:, :, 1, 1]
    # (0, 1) in right/bottom coordinates
    weight[:, 0, 0, :, 0, 1] = old_weight[:, :, 0, 2]
    weight[:, 1, 0, :, 0, 1] = old_weight[:, :, 1, 2]
    if old_conv.kernel_size[1] == 4:
        weight[:, 0, 1, :, 0, 1] = old_weight[:, :, 0, 3]
        weight[:, 1, 1, :, 0, 1] = old_weight[:, :, 1, 3]
    # (1, 0) in right/bottom coordinates
    weight[:, 0, 0, :, 1, 0] = old_weight[:, :, 2, 0]
    weight[:, 0, 1, :, 1, 0] = old_weight[:, :, 2, 1]
    if old_conv.kernel_size[0] == 4:
        weight[:, 1, 0, :, 1, 0] = old_weight[:, :, 3, 0]
        weight[:, 1, 1, :, 1, 0] = old_weight[:, :, 3, 1]
    # (1, 1) in right/bottom coordinates
    weight[:, 0, 0, :, 1, 1] = old_weight[:, :, 2, 2]
    if old_conv.kernel_size[1] == 4:
        weight[:, 0, 1, :, 1, 1] = old_weight[:, :, 2, 3]
    if old_conv.kernel_size[0] == 4:
        weight[:, 1, 0, :, 1, 1] = old_weight[:, :, 3, 2]
    if all(k == 4 for k in old_conv.kernel_size):
        weight[:, 1, 1, :, 1, 1] = old_weight[:, :, 3, 3]

    conv = Conv2d(12, old_conv.out_channels, 2, 1,
                  bias=old_conv.use_bias,
                  padding=old_conv.padding == "same",
                  groups=old_conv.groups)
    conv.weight.data[:] = weight.reshape(old_conv.out_channels,
                                         12, 2, 2)
    return conv


class UnfoldedDemosaic(Demosaic):
    def forward(self, x):
        x = self.module(x)
        if askeras.use_keras:
            return self.as_keras(x)
        *B, C, H, W = x.shape
        assert C == 12
        permute = 2, 3, 0, 4, 1
        permute = (*B,) + (v + len(B) for v in permute)
        return x.reshape(*B, 2, 2, 3, H, W
                         ).permute(permute
                                   ).reshape(*B, 3, 2 * H, 2 * W)

    def as_keras(self, x):
        from keras.layers import Reshape, Transpose
        H, W = askeras.kwds['imgsz']
        Reshape((H, W, 3))(
            Transpose((1, 3, 2, 4, 5))(
                Reshape((H//2, W//2, 2, 2, 3))(x)
            )
        )
